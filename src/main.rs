use chrono::{DateTime, Datelike, Local, NaiveDate, NaiveTime};
use clap::Parser;
use colored::*;
use prettytable::format;
use prettytable::{Cell, Row, Table, row};
use rand::Rng;
use serde::de::Error as DeError;
use serde::{Deserialize, Deserializer, Serialize, Serializer};
use std::collections::HashMap;
use std::io::{self, Write};
use std::thread;
use std::time::{Duration, Instant};
use std::{env, fs, process};
use uuid::Uuid;

// Include the version information generated by build.rs
include!(concat!(env!("OUT_DIR"), "/version.rs"));

#[derive(Parser, Debug)]
#[command(author, version, about, long_about = None)]
struct Args {
    /// Number of rounds
    #[arg(default_value_t = 5)]
    rounds: u32,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
struct Attempt {
    attempt_id: String,
    duration_ms: u128,
    #[serde(
        serialize_with = "serialize_datetime",
        deserialize_with = "deserialize_datetime"
    )]
    time: Option<DateTime<Local>>,
}

fn serialize_datetime<S>(date: &Option<DateTime<Local>>, serializer: S) -> Result<S::Ok, S::Error>
where
    S: Serializer,
{
    match date {
        Some(d) => serializer.serialize_str(&d.to_rfc3339()),
        None => serializer.serialize_none(),
    }
}

fn deserialize_datetime<'de, D>(deserializer: D) -> Result<Option<DateTime<Local>>, D::Error>
where
    D: Deserializer<'de>,
{
    let opt = Option::<String>::deserialize(deserializer)?;
    match opt {
        Some(s) => DateTime::parse_from_rfc3339(&s)
            .map(|dt| Some(dt.with_timezone(&Local)))
            .map_err(D::Error::custom),
        None => Ok(None),
    }
}

#[derive(Serialize, Deserialize, Debug, Default)]
struct DailyRecord {
    dawn: Vec<Attempt>,
    morning: Vec<Attempt>,
    noon: Vec<Attempt>,
    afternoon: Vec<Attempt>,
    evening: Vec<Attempt>,
    dusk: Vec<Attempt>,
    night: Vec<Attempt>,
    midnight: Vec<Attempt>,
}

impl DailyRecord {
    fn add_attempt(&mut self, attempt: Attempt) -> Option<String> {
        let now = Local::now().time();
        let midnight = (
            NaiveTime::from_hms_opt(0, 0, 0).unwrap(),
            NaiveTime::from_hms_opt(4, 0, 0).unwrap(),
        );
        let dawn = (
            NaiveTime::from_hms_opt(4, 0, 0).unwrap(),
            NaiveTime::from_hms_opt(6, 0, 0).unwrap(),
        );
        let morning = (
            NaiveTime::from_hms_opt(6, 0, 0).unwrap(),
            NaiveTime::from_hms_opt(10, 0, 0).unwrap(),
        );
        let noon = (
            NaiveTime::from_hms_opt(10, 0, 0).unwrap(),
            NaiveTime::from_hms_opt(14, 0, 0).unwrap(),
        );
        let afternoon = (
            NaiveTime::from_hms_opt(14, 0, 0).unwrap(),
            NaiveTime::from_hms_opt(17, 0, 0).unwrap(),
        );
        let evening = (
            NaiveTime::from_hms_opt(17, 0, 0).unwrap(),
            NaiveTime::from_hms_opt(19, 0, 0).unwrap(),
        );
        let dusk = (
            NaiveTime::from_hms_opt(19, 0, 0).unwrap(),
            NaiveTime::from_hms_opt(21, 0, 0).unwrap(),
        );
        let night = (
            NaiveTime::from_hms_opt(21, 0, 0).unwrap(),
            NaiveTime::from_hms_opt(23, 59, 59).unwrap(),
        );

        if now >= midnight.0 && now < midnight.1 {
            self.midnight.push(attempt);
            Some("midnight".to_string())
        } else if now >= dawn.0 && now < dawn.1 {
            self.dawn.push(attempt);
            Some("dawn".to_string())
        } else if now >= morning.0 && now < morning.1 {
            self.morning.push(attempt);
            Some("morning".to_string())
        } else if now >= noon.0 && now < noon.1 {
            self.noon.push(attempt);
            Some("noon".to_string())
        } else if now >= afternoon.0 && now < afternoon.1 {
            self.afternoon.push(attempt);
            Some("afternoon".to_string())
        } else if now >= evening.0 && now < evening.1 {
            self.evening.push(attempt);
            Some("evening".to_string())
        } else if now >= dusk.0 && now < dusk.1 {
            self.dusk.push(attempt);
            Some("dusk".to_string())
        } else if now >= night.0 && now <= night.1 {
            self.night.push(attempt);
            Some("night".to_string())
        } else {
            None
        }
    }

    fn sort_attempts(&mut self) {
        let sort_fn = |a: &Attempt, b: &Attempt| a.time.cmp(&b.time);
        self.midnight.sort_by(sort_fn);
        self.dawn.sort_by(sort_fn);
        self.morning.sort_by(sort_fn);
        self.noon.sort_by(sort_fn);
        self.afternoon.sort_by(sort_fn);
        self.evening.sort_by(sort_fn);
        self.dusk.sort_by(sort_fn);
        self.night.sort_by(sort_fn);
    }
}

#[derive(Serialize, Deserialize, Debug, Default)]
struct VersionedRecords {
    version: String,
    records: HashMap<String, DailyRecord>,
}

fn load_daily_record(file_path: &str) -> VersionedRecords {
    if let Ok(file) = fs::File::open(file_path) {
        if let Ok(record) = serde_json::from_reader(file) {
            return record;
        }
    }
    VersionedRecords::default()
}

fn save_daily_record(record: &VersionedRecords, file_path: &str) {
    // for (_, daily_record) in record.records.iter_mut() {
    //     daily_record.sort_attempts();
    // }
    if let Ok(file) = fs::File::create(file_path) {
        let _ = serde_json::to_writer_pretty(file, record);
        println!("Records saved to {}", file_path);
    }
}
fn calculate_average(attempts: &[Attempt]) -> Option<f64> {
    if attempts.is_empty() {
        return None;
    }
    Some(attempts.iter().map(|a| a.duration_ms as f64).sum::<f64>() / attempts.len() as f64)
}

fn get_attempts_for_time_range<'a>(daily_record: &'a DailyRecord, range: &str) -> &'a [Attempt] {
    match range {
        "dawn" => &daily_record.dawn,
        "morning" => &daily_record.morning,
        "noon" => &daily_record.noon,
        "afternoon" => &daily_record.afternoon,
        "evening" => &daily_record.evening,
        "dusk" => &daily_record.dusk,
        "night" => &daily_record.night,
        "midnight" => &daily_record.midnight,
        _ => &[],
    }
}
fn get_average_for_period(
    record: &VersionedRecords,
    period: &str,
    time_range: &str,
) -> Option<f64> {
    let now = Local::now().date_naive();
    let start_date = match period {
        "today" => now,
        "this_week" => {
            let weekday = now.weekday().num_days_from_monday();
            now - chrono::Duration::days(weekday as i64)
        }
        "last_week" => {
            let weekday = now.weekday().num_days_from_monday();
            now - chrono::Duration::days((weekday + 7) as i64)
        }
        _ => return None,
    };
    let end_date = match period {
        "today" => now + chrono::Duration::days(1),
        "this_week" => start_date + chrono::Duration::days(7),
        "last_week" => start_date + chrono::Duration::days(7),
        _ => return None,
    };

    let mut attempts = Vec::new();

    for (date, daily_record) in &record.records {
        let record_date = NaiveDate::parse_from_str(date, "%Y-%m-%d").unwrap();
        if record_date >= start_date && record_date < end_date {
            attempts.extend_from_slice(get_attempts_for_time_range(daily_record, time_range));
        }
    }

    calculate_average(&attempts)
}

fn get_average_for_period_all_ranges(record: &VersionedRecords, period: &str) -> Option<f64> {
    let now = Local::now().date_naive();
    let start_date = match period {
        "today" => now,
        "this_week" => {
            let weekday = now.weekday().num_days_from_monday();
            now - chrono::Duration::days(weekday as i64)
        }
        "last_week" => {
            let weekday = now.weekday().num_days_from_monday();
            now - chrono::Duration::days((weekday + 7) as i64)
        }
        _ => return None,
    };
    let end_date = match period {
        "today" => now + chrono::Duration::days(1),
        "this_week" => start_date + chrono::Duration::days(7),
        "last_week" => start_date + chrono::Duration::days(7),
        _ => return None,
    };

    let mut attempts = Vec::new();

    for (date, daily_record) in &record.records {
        let record_date = NaiveDate::parse_from_str(date, "%Y-%m-%d").unwrap();
        if record_date >= start_date && record_date < end_date {
            attempts.extend_from_slice(&daily_record.dawn);
            attempts.extend_from_slice(&daily_record.morning);
            attempts.extend_from_slice(&daily_record.noon);
            attempts.extend_from_slice(&daily_record.afternoon);
            attempts.extend_from_slice(&daily_record.evening);
            attempts.extend_from_slice(&daily_record.dusk);
            attempts.extend_from_slice(&daily_record.night);
            attempts.extend_from_slice(&daily_record.midnight);
        }
    }

    calculate_average(&attempts)
}

fn print_comparison_table(current_avg: f64, time_range: &str, record: &VersionedRecords) {
    let today_avg = get_average_for_period(record, "today", time_range);
    let this_week_avg = get_average_for_period(record, "this_week", time_range);
    let last_week_avg = get_average_for_period(record, "last_week", time_range);
    let today_all_avg = get_average_for_period_all_ranges(record, "today");
    let this_week_all_avg = get_average_for_period_all_ranges(record, "this_week");
    let last_week_all_avg = get_average_for_period_all_ranges(record, "last_week");

    let mut table = Table::new();
    table.set_format(*format::consts::FORMAT_NO_LINESEP_WITH_TITLE);
    table.set_titles(row!["Comparison Range", "Specific Time Range", "All Time Ranges"]);

    table.add_row(row![
        "Today",
        format_comparison(current_avg, today_avg),
        format_comparison(current_avg, today_all_avg)
    ]);
    table.add_row(row![
        "This Week",
        format_comparison(current_avg, this_week_avg),
        format_comparison(current_avg, this_week_all_avg)
    ]);
    table.add_row(row![
        "Last Week",
        format_comparison(current_avg, last_week_avg),
        format_comparison(current_avg, last_week_all_avg)
    ]);

    table.printstd();
}

fn format_comparison(current_avg: f64, historical_avg: Option<f64>) -> String {
    if let Some(avg) = historical_avg {
        let change = current_avg - avg;
        let change_percentage = (change / avg) * 100.0;
        let (avg_str, change_pct_str);
        if change > 0.0 {
            avg_str = format!("{:.2}ms", avg).bold().to_string();
            change_pct_str = format!("↑{:.2}%", change_percentage).red().to_string();
        } else {
            avg_str = format!("{:.2}ms", avg).bold().to_string();
            change_pct_str = format!("↓{:.2}%", -change_percentage).green().to_string();
        }
        format!("{} ({})", avg_str, change_pct_str)
    } else {
        "No historical data".to_string()
    }
}

fn main() {
    let args = Args::parse();

    println!("Reaction Speed Test");
    println!("-------------------");
    println!("Press [Enter] as quickly as possible when you see the new line.");
    println!("Press [Ctrl+D] or [Ctrl+C] to exit.\n");

    let mut total_duration = Duration::new(0, 0);

    // Get the binary directory
    let exe_path = env::current_exe().expect("Failed to get the executable path");
    let exe_dir = exe_path
        .parent()
        .expect("Failed to get the executable directory");
    let log_file_path = exe_dir.join("reaction_speed_log.json");
    let log_file_path = log_file_path
        .to_str()
        .expect("Failed to convert path to string");

    let mut record = load_daily_record(log_file_path);
    record.version = VERSION.to_string();
    println!("Log file path: {}", log_file_path);

    let today = Local::now().date_naive().format("%Y-%m-%d").to_string();
    let daily_record = record.records.entry(today.clone()).or_default();

    let mut range = None;
    for round in 1..=args.rounds {
        let mut early_press = false;

        loop {
            if early_press {
                println!("{}", "Too early! Wait for the prompt and try again.".red());
            }

            println!("Round {} of {}", round, args.rounds);
            print!("Ready? [Enter] to start ");
            io::stdout().flush().unwrap(); // Ensure the message is printed immediately
            let mut input = String::new();
            if let Ok(_) = io::stdin().read_line(&mut input) {
                println!("Wait a second...");
                thread::sleep(Duration::from_secs(1));
            } else {
                println!("Error reading input");
                process::exit(1);
            }
            println!("Get ready...");
            let delay = rand::thread_rng().gen_range(1000..10000); // Random delay between 1 to 8 seconds
            thread::sleep(Duration::from_millis(delay));

            let start = Instant::now();
            print!("{}", "\nPress [Enter] now!".bold());
            io::stdout().flush().unwrap(); // Ensure the message is printed immediately

            let mut input = String::new();
            match io::stdin().read_line(&mut input) {
                Ok(_) => {
                    let duration = start.elapsed();
                    if duration < Duration::from_millis(50) {
                        // If the user presses [Enter] too early
                        early_press = true;
                        continue;
                    } else {
                        total_duration += duration;
                        let attempt = Attempt {
                            attempt_id: Uuid::new_v4().to_string(),
                            duration_ms: duration.as_millis(),
                            time: Some(Local::now()),
                        };
                        range = daily_record.add_attempt(attempt);
                        let duration = format!("{:.2?}", duration);
                        println!("Your reaction time: {}\n", duration.bold());
                        break;
                    }
                }
                Err(error) => {
                    println!("Error reading input: {}", error);
                    process::exit(1);
                }
            }
        }
    }
    save_daily_record(&record, log_file_path);

    let average_duration = total_duration / args.rounds;
    let avg_duration = format!("{:.2?}", average_duration);
    println!(
        "Average reaction time over {} rounds: {}\n",
        args.rounds, avg_duration.bold()
    );

    if let Some(range) = range {
        print_comparison_table(average_duration.as_millis() as f64, range.as_str(), &record);
    }
}
